#!/usr/bin/env python

import functools
import hashlib
import os
import sqlite3
import subprocess
import textwrap

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from flask import Flask, request, session, redirect


HOST = os.getenv("CHAT_HOST", "127.0.0.1")
PORT = int(os.getenv("CHAT_PORT", 8080))
DB_PATH = os.getenv("DB_PATH", "./chat.db")
ADMIN_PIN_PATH = os.getenv("ADMIN_PIN_PATH", "./admin.pin")
CHECK_ADMIN_PIN_PATH = os.getenv("CHECK_ADMIN_PIN_PATH", "./check-admin-pin")


app = Flask(__name__)


def initialize_db():
    db = sqlite3.connect(DB_PATH)
    db.execute("CREATE TABLE IF NOT EXISTS users (username TEXT, hashed_password TEXT, admin BOOLEAN)")
    db.execute("CREATE TABLE IF NOT EXISTS encrypted_chats (encrypted_username_1 TEXT, encrypted_username_2 TEXT, encrypted_contents TEXT)")
    return db

db = initialize_db()


def encrypt(data, key=None):
    cipher = AES.new(app.secret_key, AES.MODE_ECB)
    return cipher.encrypt(pad(data, cipher.block_size))


def decrypt(data, key=None):
    cipher = AES.new(app.secret_key, AES.MODE_ECB)
    try:
        return unpad(cipher.decrypt(data), cipher.block_size)
    except ValueError:
        raise RuntimeError("Invalid padding")


def authed_only(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if "username" not in session:
            return "You are not logged in! Please <a href='/login'>login</a> or <a href='/register'>register</a>.", 403
        return func(*args, **kwargs)
    return wrapper


@app.after_request
def format_response(response):
    if response.content_type.startswith("text/html"):
        original_data = response.get_data(as_text=True)
        dedented_data = textwrap.dedent(original_data).strip() + "\n"
        response.set_data(dedented_data)
    return response


@app.route("/")
def index():
    if "username" not in session:
        return 'Hello! Please <a href="/login">login</a> or <a href="/register">register</a>.'
    return f"""Hello {session['username']}! You are {'an admin' if session.get('admin') else 'not an admin'}.
    <br>
    <form action="/chat" method="get">
        <input type="text" name="other_username" placeholder="Username" required>
        <input type="submit" value="Chat">
    </form>
    """


@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "GET":
        return """
        <form method="post">
            <input type="text" name="username" placeholder="Username" required>
            <input type="password" name="password" placeholder="Password" required>
            <input type="submit" value="Register">
        </form>
        """
    try:
        username = request.form["username"]
        password = request.form["password"]
    except KeyError:
        return "Missing username or password. Back to <a href='/'>home</a>.", 400
    if db.execute(f"SELECT * FROM users WHERE username='{username}'").fetchone():
        return "Username already exists. Back to <a href='/'>home</a>.", 400
    hashed_password = hashlib.sha256(password.encode()).hexdigest()
    admin = request.remote_addr == "127.0.0.1"
    db.execute(f"INSERT INTO users VALUES ('{username}', '{hashed_password}', {'true' if admin else 'false'})")
    db.commit()
    session["username"] = username
    session["admin"] = admin
    return redirect("/")


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "GET":
        return """
        <form method="post">
            <input type="text" name="username" placeholder="Username" required>
            <input type="password" name="password" placeholder="Password" required>
            <input type="submit" value="Login">
        </form>
        """
    try:
        username = request.form["username"]
        password = request.form["password"]
    except KeyError:
        return "Missing username or password. Back to <a href='/'>home</a>.", 400
    hashed_password = hashlib.sha256(password.encode()).hexdigest()
    result =  db.execute(f"SELECT * FROM users WHERE username='{username}' and hashed_password='{hashed_password}'").fetchone()
    if not result:
        return "Invalid username or password. Back to <a href='/'>home</a>.", 400
    username, _, admin = result

    if admin and request.remote_addr != "127.0.0.1":
        return "Admins may only login locally. Back to <a href='/'>home</a>.", 403

    session["username"] = username
    session["admin"] = admin
    return redirect("/")


@app.route("/chat/", methods=["GET"])
@app.route("/chat/<other_username>", methods=["HEAD", "GET", "POST"])
@authed_only
def chat(other_username=None):
    if request.args.get("other_username"):
        return redirect(f"/chat/{request.args['other_username']}")

    username = session["username"]

    result = db.execute(f"SELECT * FROM users WHERE username='{other_username}'").fetchone()
    if not result:
        return "User does not exist. Back to <a href='/'>home</a>.", 404

    encrypted_username_1, encrypted_username_2 = sorted([encrypt(username.encode()).hex(), encrypt(other_username.encode()).hex()])
    result = db.execute(f"SELECT encrypted_contents FROM encrypted_chats WHERE encrypted_username_1='{encrypted_username_1}' AND encrypted_username_2='{encrypted_username_2}'").fetchone()
    try:
        contents = decrypt(bytes.fromhex(result[0])).decode() if result else ""
    except RuntimeError:
        # Failed to correctly decrypt, web server restarted (and generated a new secret key) or it was tampered with
        # Delete the chat and start a new one
        contents = ""

    etag = hashlib.sha256(contents.encode()).hexdigest()

    if request.method == "HEAD":
        return "", 200, {"ETag": etag}

    if request.method == "GET":
        contents_html = "\n<br>\n".join(contents.splitlines())
        return f"""
            <main>
                {contents_html}
            </main>
            <form method="post">
                <input id="message" type="text" name="message" placeholder="Message" required>
                <input type="submit" value="Send">
            </form>
            <script>
                let etag = "{etag}";
                window.scrollTo(0, document.body.scrollHeight);
                message.value = localStorage.getItem("message") || "";
                localStorage.removeItem("message");
                message.focus();
                interval = setInterval(() => {{
                    fetch(location.href, {{method: "HEAD"}}).then(response => {{
                        if (response.headers.get("ETag") !== etag) {{
                            localStorage.setItem("message", message.value);
                            location.reload();
                        }}
                    }});
                }}, 5000);
            </script>
        """, 200, {"ETag": etag}

    if request.method == "POST":
        try:
            message = request.form["message"].strip().replace("\n", " ")
        except KeyError:
            return "Missing message. Back to <a href='/'>home</a>.", 400
        encrypted_contents = encrypt((contents + f"{username}: {message}\n").encode()).hex()
        if contents:
            db.execute(f"UPDATE encrypted_chats SET encrypted_contents='{encrypted_contents}' WHERE encrypted_username_1='{encrypted_username_1}' AND encrypted_username_2='{encrypted_username_2}'")
        else:
            db.execute(f"INSERT INTO encrypted_chats VALUES ('{encrypted_username_1}', '{encrypted_username_2}', '{encrypted_contents}')")
        db.commit()
        return redirect(f"/chat/{other_username}")


@app.route("/user/modify", methods=["GET"])
@app.route("/user/<username>/modify", methods=["GET", "POST"])
@authed_only
def modify_user(username=None):
    if username is None:
        return redirect(f"/user/{session['username']}/modify")

    result = db.execute(f"SELECT * FROM users WHERE username='{username}'").fetchone()
    if not result:
        return "User does not exist. Back to <a href='/'>home</a>.", 400
    username, password, admin = result

    if request.method == "GET" and session["admin"]:
        return f"""
        Modify user {username}:
        <form method="post">
            <input type="text" name="username" placeholder="Username" value="{username}">
            <input type="password" name="password" placeholder="Password">
            <input type="checkbox" name="admin" value="{'true' if admin else 'false'}"> Admin
            <input type="password" name="admin_pin" value="" required>
            <input type="submit" value="Modify">
            <input type="submit" name="delete" value="Delete User">
        </form>
        """
    elif request.method == "GET" and not session["admin"]:
        return f"""
        Modify user {username}:
        <form method="post">
            <input type="password" name="password" placeholder="Password">
            <input type="submit" value="Modify">
            <input type="submit" name="delete" value="Delete">
        </form>
        """

    admin_only = session["username"] != username or any(name in request.form for name in ("username", "admin"))

    if admin_only and not session.get("admin"):
        return "You must be an admin to modify other users. Back to <a href='/'>home</a>.", 403

    if admin_only:
        try:
            admin_pin = request.form["admin_pin"]
        except KeyError:
            return "Missing admin pin. Back to <a href='/'>home</a>.", 400

        result = subprocess.run([CHECK_ADMIN_PIN_PATH],
                                env={"ADMIN_PIN_PATH": ADMIN_PIN_PATH},
                                input=admin_pin,
                                capture_output=True,
                                text=True,
                                encoding="latin-1")
        if result.returncode != 0:
            stderr = result.stderr.strip()
            return f"{stderr}. Back to <a href='/'>home</a>.", 403

    encrypted_username = encrypt(username.encode()).hex()

    if "delete" in request.form:
        db.execute(f"DELETE FROM users WHERE username='{username}'")
        db.execute(f"UPDATE encrypted_chats SET encrypted_username_1=NULL WHERE encrypted_username_1='{encrypted_username}'")
        db.execute(f"UPDATE encrypted_chats SET encrypted_username_2=NULL WHERE encrypted_username_2='{encrypted_username}'")
        db.execute(f"DELETE FROM encrypted_chats WHERE encrypted_username_1 IS NULL AND encrypted_username_2 IS NULL")
        db.commit()
        if session["username"] == username:
            session.clear()
        return "User deleted. Back to <a href='/'>home</a>."

    new_username = request.form.get("username", username)
    new_password = hashlib.sha256(request.form["password"]).hexdigest() if request.form.get("password") else password
    new_admin = request.form.get("admin", ("true" if admin else "false")) == "true"

    db.execute(f"UPDATE users SET username='{new_username}', hashed_password='{new_password}', admin={'true' if new_admin else 'false'} WHERE username='{username}'")

    if new_username != username:
        encrypted_username = encrypt(username.encode()).hex()
        encrypted_new_username = encrypt(new_username.encode()).hex()
        result = db.execute(f"SELECT * FROM encrypted_chats WHERE encrypted_username_1='{encrypted_username}' OR encrypted_username_2='{encrypted_username}'").fetchall()
        for encrypted_username_1, encrypted_username_2, encrypted_contents in result:
            contents = decrypt(bytes.fromhex(encrypted_contents)).decode()
            new_encrypted_username_1, new_encrypted_username_2 = sorted([encrypted_new_username if encrypted_username_1 == encrypted_username else encrypted_username_1,
                                                                         encrypted_new_username if encrypted_username_2 == encrypted_username else encrypted_username_2],
                                                                        key=lambda k: k or "")
            new_encrypted_contents = encrypt("".join(
                (line.replace(f"{username}: ", f"{new_username}: ", 1) if line.startswith(f"{username}: ") else line) + "\n"
                for line in contents.splitlines()
            ).encode()).hex()
            sql_set = ", ".join(f"{k}='{v}'" if v is not None else f"{k}=NULL" for k, v in
                                dict(encrypted_username_1=new_encrypted_username_1,
                                     encrypted_username_2=new_encrypted_username_2,
                                     encrypted_contents=new_encrypted_contents).items())
            sql_where = " AND ".join(f"{k}='{v}'" if v is not None else f"{k} IS NULL" for k, v in
                                     dict(encrypted_username_1=encrypted_username_1,
                                          encrypted_username_2=encrypted_username_2,
                                          encrypted_contents=encrypted_contents).items())
            db.execute(f"UPDATE encrypted_chats SET {sql_set} WHERE {sql_where}")

    db.commit()
    if session["username"] == username:
        if new_username != username:
            session["username"] = new_username
        if new_admin != admin:
            session["admin"] = new_admin

    return "User modified. Back to <a href='/'>home</a>."


if __name__ == "__main__":
    app.secret_key = os.urandom(16)
    app.run(host=HOST, port=PORT, threaded=False)
